- (2025-05-04) started with chapter 6 Dependencies. Chapter 4 were an introduction on FastAPI, Starlette, concurrency computing, asyncio and other parallel processing ideas. Chapter 5 were for pydantic and type hinting. Exciting in ch 5 i first call on different layers for a web app, the model layer that define the schema for the data, the data layer that create a data base for the web following the rules of the model layer and the web layer that defines the client endpoint
-(2025-05-06) starting with the 6 chapter about FastAPI Dependencies the last page was 100
-(2025-05-06) chapter 6 development continues, were we read about dependency injection for getting data we need when we need it and validate them in a straightforward way. Then in chapter 7 we read about the differences in web frameworks for python language, here the interesting part is that django is recommended for data intense applications and FastAPI is recommended for deploy fast and easy. Continue in page 114
-(2025-05-07) chapter 8 cool introduction to a full end-to-end web service. Continue the reading from page 119
-(2025-05-07) development of the chapter 8 continues, we face the challange of use different directories like packages and use at the same time poetry, we try to set in the .toml file of poetry manager the route of this package but doesn't work. Finally with assistance of ChatGPT we could workaround with the command PYTHONPATH=<source path> that tells python were to looking for modules first, this works nicely. Continue reading form page 120
-(2025-05-08) development of the chapter 8 continues, we reinforce the idea for call the python run command over the .py file with the uvicorn server module with 'PYTHONPATH=.', this path ensure that the directories inside the one were we are be taken as packages for the run. Next we learn how to connect different layers of the web service, first we have the web client layer with the .py file called 'main', this layer deploy the server for the service and call the router instance, of fastAPI, for redirect endpoints of the service. Then we have the web server, this layer define the logic of the service, that means the the endpoints available for the clients and the functions associated with them, in this layer we need to define the router instance that gonna be called for the web client server, to this instance is passed the prefix for every endpoint. In the next layer we have service layer, this layer connect the data layer and the web layer, and define the algorithms for the functions available for the service. The model layer define the structures of the data and the data layer is not developed for now. Inside the main.py script were the server is deployed we need to specify the include of the APIRouter. Inside of every 'package' or directory we define inside the corresponding script the router, this facilitates the use of differents routers in the host. 
-(2025-05-08) in the last part of the content read the book make something wrong because define empty functions that do nothing but when test it in the examples this functions make something. For recreate the test process we transform this functions to a minimum, like at least take some 'name:str' in the path and generate a response with that data. With this the test process was a success. Continue reading from page 137
-(2025-05-11) in chapter 9 we develop the service layer, for now is connected to the fake package, this make as data layer. In this layer we need to specify the logic of the web service with the necessary functions, again, for now is calling functions on the fake package. Then we learn about testing the logic and connections with pytest module in python, for that we create a new directory in the same level of the other layers and inside of this we create a 'unit' and 'full' directory, the first for test each layer at a time and the second for all of them at the same time. Because of that in the 'unit' directory we define another directories for each layer. Then in every directory the proper .py file of the layer, inside of this file we need to recreate the logic necessary for the test. I don't understand if this we need to do every time we want to test some service of if it only an example, now that i write that i understand that this .py files inside the test directory are calling the true service of the web app. For run the test we need to specify the path to the packages, that with 'PYTHONPATH=.' then we can pass the command for poetry run.
-(2025-05-11) in the last part of the chapter 9 we learn about the concepts of logging, metrics, monitoring and tracing. This concepts are useful for the maintainability, reliability and scalability of the site. Continue reading from chapter 10
-(2025-05-11) continue reading from page 154
-(2025-05-11) in the chapter 10 we learn about the data layer, this ch introduce to the build-in module data structure sqlite for python, sqlite3. And create the files into the data layer for CRUD processes, create, get(retrieve), modify(update) and delete. We view that the create of the db table may be handle in other script called init, this script when imported in others .py files create the table if doesn't exist. Here we introduce the concept of environment variables and the module python-dotenv for manage this, the environment variable is set for security of the db, we don't want someone entering for back doors. For run and test the new data layer we need to change the references in every layer (web and service), then we need to deploy the server with 'PYTHONPATH=. poetry run python...' and we need to pay attention on the paths decorator for each endpoint. Some interesting observation or problem that appears here is that when we define some class with a name with white space like 'lucas acosta' the db brakes, perhaps more research is needed on this situation. Another problem that appeared is that we change every layer for access to the new data layer but not the model layer, when we pass the create endpoint some data that did not comply with the rules of this layer break the app. Continues reading from page 163
-(2025-05-14) in the last part of chapter 10 we test the endpoints fore CRUD, for that purpose we call the command POST for Create, GET for Retrive, PATCH for Update and DELETE for Delete. This HTTP requests actions are linked to a path endpoint of the web layer, something that we learn or discover is that the prescence of spaces in the name of the Creature instance when we create and then retrive the data from the endpoint is not a problem, the problem is that we where putting a comma between parameter when run the POST request and this break the syntax of the data (the comma is introduced in the value of the paremeter). Other thing that we learn is the different status code for specify the result of a request. We learn how to handle missing data and duplicate data, for that we need to create a new module called 'common' fromm this we gonna call inside of the data layer and the web layer the instances necessary for reproduce the messages, this messages gonna be created in the data layer, pass through the service layer and taked for the web layer for diplay in the response of the request. Important here is that in the delete function of the data layer when we try to call some value missing the sql module retunr a value of 0 and dont pop an error so the algorithm for assert the missing value is not function. For change this we need to refactor the algorithm for count how values response the DB. Lastly we try to use the module pytest for automatic testing but this not work like we expected. A lot of the code in the book is bad so maybe talking to ChatGpt helps. For more information on problems we encounter, read the chat with openAI bot in this day
