- (2025-05-04) started with chapter 6 Dependencies. Chapter 4 were an introduction on FastAPI, Starlette, concurrency computing, asyncio and other parallel processing ideas. Chapter 5 were for pydantic and type hinting. Exciting in ch 5 i first call on different layers for a web app, the model layer that define the schema for the data, the data layer that create a data base for the web following the rules of the model layer and the web layer that defines the client endpoint
-(2025-05-06) starting with the 6 chapter about FastAPI Dependencies the last page was 100
-(2025-05-06) chapter 6 development continues, were we read about dependency injection for getting data we need when we need it and validate them in a straightforward way. Then in chapter 7 we read about the differences in web frameworks for python language, here the interesting part is that django is recommended for data intense applications and FastAPI is recommended for deploy fast and easy. Continue in page 114
-(2025-05-07) chapter 8 cool introduction to a full end-to-end web service. Continue the reading from page 119
-(2025-05-07) development of the chapter 8 continues, we face the challange of use different directories like packages and use at the same time poetry, we try to set in the .toml file of poetry manager the route of this package but doesn't work. Finally with assistance of ChatGPT we could workaround with the command PYTHONPATH=<source path> that tells python were to looking for modules first, this works nicely. Continue reading form page 120
-(2025-05-08) development of the chapter 8 continues, we reinforce the idea for call the python run command over the .py file with the uvicorn server module with 'PYTHONPATH=.', this path ensure that the directories inside the one were we are be taken as packages for the run. Next we learn how to connect different layers of the web service, first we have the web client layer with the .py file called 'main', this layer deploy the server for the service and call the router instance, of fastAPI, for redirect endpoints of the service. Then we have the web server, this layer define the logic of the service, that means the the endpoints available for the clients and the functions associated with them, in this layer we need to define the router instance that gonna be called for the web client server, to this instance is passed the prefix for every endpoint. In the next layer we have service layer, this layer connect the data layer and the web layer, and define the algorithms for the functions available for the service. The model layer define the structures of the data and the data layer is not developed for now. Inside the main.py script were the server is deployed we need to specify the include of the APIRouter. Inside of every 'package' or directory we define inside the corresponding script the router, this facilitates the use of differents routers in the host. 
-(2025-05-08) in the last part of the content read the book make something wrong because define empty functions that do nothing but when test it in the examples this functions make something. For recreate the test process we transform this functions to a minimum, like at least take some 'name:str' in the path and generate a response with that data. With this the test process was a success. Continue reading from page 137
-(2025-05-11) in chapter 9 we develop the service layer, for now is connected to the fake package, this make as data layer. In this layer we need to specify the logic of the web service with the necessary functions, again, for now is calling functions on the fake package. Then we learn about testing the logic and connections with pytest module in python, for that we create a new directory in the same level of the other layers and inside of this we create a 'unit' and 'full' directory, the first for test each layer at a time and the second for all of them at the same time. Because of that in the 'unit' directory we define another directories for each layer. Then in every directory the proper .py file of the layer, inside of this file we need to recreate the logic necessary for the test. I don't understand if this we need to do every time we want to test some service of if it only an example, now that i write that i understand that this .py files inside the test directory are calling the true service of the web app. For run the test we need to specify the path to the packages, that with 'PYTHONPATH=.' then we can pass the command for poetry run.
-(2025-05-11) in the last part of the chapter 9 we learn about the concepts of logging, metrics, monitoring and tracing. This concepts are useful for the maintainability, reliability and scalability of the site. Continue reading from chapter 10
-(2025-05-11) continue reading from page 154
-(2025-05-11) in the chapter 10 we learn about the data layer, this ch introduce to the build-in module data structure sqlite for python, sqlite3. And create the files into the data layer for CRUD processes, create, get(retrieve), modify(update) and delete. We view that the create of the db table may be handle in other script called init, this script when imported in others .py files create the table if doesn't exist. Here we introduce the concept of environment variables and the module python-dotenv for manage this, the environment variable is set for security of the db, we don't want someone entering for back doors. For run and test the new data layer we need to change the references in every layer (web and service), then we need to deploy the server with 'PYTHONPATH=. poetry run python...' and we need to pay attention on the paths decorator for each endpoint. Some interesting observation or problem that appears here is that when we define some class with a name with white space like 'lucas acosta' the db brakes, perhaps more research is needed on this situation. Another problem that appeared is that we change every layer for access to the new data layer but not the model layer, when we pass the create endpoint some data that did not comply with the rules of this layer break the app. Continues reading from page 163
-(2025-05-14) in the last part of chapter 10 we test the endpoints fore CRUD, for that purpose we call the command POST for Create, GET for Retrive, PATCH for Update and DELETE for Delete. This HTTP requests actions are linked to a path endpoint of the web layer, something that we learn or discover is that the prescence of spaces in the name of the Creature instance when we create and then retrive the data from the endpoint is not a problem, the problem is that we where putting a comma between parameter when run the POST request and this break the syntax of the data (the comma is introduced in the value of the paremeter). Other thing that we learn is the different status code for specify the result of a request. We learn how to handle missing data and duplicate data, for that we need to create a new module called 'common' fromm this we gonna call inside of the data layer and the web layer the instances necessary for reproduce the messages, this messages gonna be created in the data layer, pass through the service layer and taked for the web layer for diplay in the response of the request. Important here is that in the delete function of the data layer when we try to call some value missing the sql module retunr a value of 0 and dont pop an error so the algorithm for assert the missing value is not function. For change this we need to refactor the algorithm for count how values response the DB. Lastly we try to use the module pytest for automatic testing but this not work like we expected. A lot of the code in the book is bad so maybe talking to ChatGpt helps. For more information on problems we encounter, read the chat with openAI bot in this day
-(2025-05-19) in the last part of the chapter 10 we try to test the logic of the service with pytest, this test outputs various errors, with the help of chatbots we encounter the problem. The test file for automatic test with pytest was pointing to the module of creatures when the logic to test was made in the explorer module. We found error in the books code. Remember that for the test we need to run the testing with 'PYTHOTPATH=. poetry run pytest <path to the .py file>'
-(2025-05-19) we start with the chapter 11 were we learn about authentication (authn) and authorization (authz). This two concepts facilitates security and control over the effectiveness of the website. Allows know the number of uniques visitors, what are the most popular pages, if changes in the website increase the views and others effective ratios. In this first part we learn that for true security we need to use HTTPS instead of HTTP and we see how to implement a simple auth logic in fastAPI, this use simples variables that saves password and user name like str and receives http request with this data, control if that data exist and pass the response. For the previous logic we use some new classes of fastapi module like HTTPBasics and HTTPBasics.Credentials. This is just an example like how the auth and auhtz is used in reallity this is not secure. For thar reason the book introduces OAuth2 standarization.
-(2025-05-20) continue the chapter 11 we remember the purpose of the two concepts, authentication is for know how are the user and authorization is for know what service the user want and can access. Here introduces first concepts to OAuth2 'Open Authorization' this is a standar protocol defined by the industry for allow websites access to resources hosted by other websites. We learn the needs for handle OAuth2, JWT (JsonWebToken) handling - with python-jose[cryptography] (JavascriptObjectSigningEncyptation) for handling token identifications, password handling - with passlib module, handling data from forms of the login logic with python-multipart module. For the last part of this day we design the logic for manage authz bottom-up, meaning that we start with the model layer were we define the classes for the login (User) then pass to the data layer and develop the tables in the db and the functions for CRUD (CreateRetrieveUpdateDelete), in the midle we create a fake data layer for test all the service without the need to define others layers with detail. Continue from the page 186 with the service and web layer
-(2025-05-21) we develop the data layer. Key ideas was to load the variables defined in the .env file, we did that with the dotenv module, this is used for not define and enviroment variable in the system and define just locally. In this layer we define the major part of the authorization logic. For now the code is calling to the fake module if the db is not defined in the .env, with this we avoid the crash of the run. For the logic of authz we need to import jwt form jose lib and CryptContex from pasllib.contex lib. Then in the code we define the SECRET_KEY, the ALGORITHM for the encode and the pwd_context for the same purpose, probably we gonna define in the .env file for production. Then we define the verify password for verify the password pased with the hash, here is used the CryptContext. The get hash function for create the hash of the password with the CryptContext (we se the relation in this firs two functions). Then the get_jwt_username take a token and return and username or none, this return only the username str-type. Then get_current_user, this return a User instance. A lookup_user function for the previous function. An auth_user function that takes name and plain pass and return user if is authenticate. Finally and create_access_token function for create the token, this have in minds the expires time of the token. The rest of the data layer is the passthrough of CRUD functions. CONTINUE FROM PAGE187
