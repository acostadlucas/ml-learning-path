- (2025-05-04) started with chapter 6 Dependencies. Chapter 4 were an introduction on FastAPI, Starlette, concurrency computing, asyncio and other parallel processing ideas. Chapter 5 were for pydantic and type hinting. Exciting in ch 5 i first call on different layers for a web app, the model layer that define the schema for the data, the data layer that create a data base for the web following the rules of the model layer and the web layer that defines the client endpoint
-(2025-05-06) starting with the 6 chapter about FastAPI Dependencies the last page was 100
-(2025-05-06) chapter 6 development continues, were we read about dependency injection for getting data we need when we need it and validate them in a straightforward way. Then in chapter 7 we read about the differences in web frameworks for python language, here the interesting part is that django is recommended for data intense applications and FastAPI is recommended for deploy fast and easy. Continue in page 114
-(2025-05-07) chapter 8 cool introduction to a full end-to-end web service. Continue the reading from page 119
-(2025-05-07) development of the chapter 8 continues, we face the challange of use different directories like packages and use at the same time poetry, we try to set in the .toml file of poetry manager the route of this package but doesn't work. Finally with assistance of ChatGPT we could workaround with the command PYTHONPATH=<source path> that tells python were to looking for modules first, this works nicely. Continue reading form page 120
-(2025-05-08) development of the chapter 8 continues, we reinforce the idea for call the python run command over the .py file with the uvicorn server module with 'PYTHONPATH=.', this path ensure that the directories inside the one were we are be taken as packages for the run. Next we learn how to connect different layers of the web service, first we have the web client layer with the .py file called 'main', this layer deploy the server for the service and call the router instance, of fastAPI, for redirect endpoints of the service. Then we have the web server, this layer define the logic of the service, that means the the endpoints available for the clients and the functions associated with them, in this layer we need to define the router instance that gonna be called for the web client server, to this instance is passed the prefix for every endpoint. In the next layer we have service layer, this layer connect the data layer and the web layer, and define the algorithms for the functions available for the service. The model layer define the structures of the data and the data layer is not developed for now. Inside the main.py script were the server is deployed we need to specify the include of the APIRouter. Inside of every 'package' or directory we define inside the corresponding script the router, this facilitates the use of differents routers in the host. 
-(2025-05-08) in the last part of the content read the book make something wrong because define empty functions that do nothing but when test it in the examples this functions make something. For recreate the test process we transform this functions to a minimum, like at least take some 'name:str' in the path and generate a response with that data. With this the test process was a success. Continue reading from page 137
-(2025-05-11) in chapter 9 we develop the service layer, for now is connected to the fake package, this make as data layer. In this layer we need to specify the logic of the web service with the necessary functions, again, for now is calling functions on the fake package. Then we learn about testing the logic and connections with pytest module in python, for that we create a new directory in the same level of the other layers and inside of this we create a 'unit' and 'full' directory, the first for test each layer at a time and the second for all of them at the same time. Because of that in the 'unit' directory we define another directories for each layer. Then in every directory the proper .py file of the layer, inside of this file we need to recreate the logic necessary for the test. I don't understand if this we need to do every time we want to test some service of if it only an example, now that i write that i understand that this .py files inside the test directory are calling the true service of the web app. For run the test we need to specify the path to the packages, that with 'PYTHONPATH=.' then we can pass the command for poetry run.
-(2025-05-11) in the last part of the chapter 9 we learn about the concepts of logging, metrics, monitoring and tracing. This concepts are useful for the maintainability, reliability and scalability of the site. Continue reading from chapter 10
-(2025-05-11) continue reading from page 154
-(2025-05-11) in the chapter 10 we learn about the data layer, this ch introduce to the build-in module data structure sqlite for python, sqlite3. And create the files into the data layer for CRUD processes, create, get(retrieve), modify(update) and delete. We view that the create of the db table may be handle in other script called init, this script when imported in others .py files create the table if doesn't exist. Here we introduce the concept of environment variables and the module python-dotenv for manage this, the environment variable is set for security of the db, we don't want someone entering for back doors. For run and test the new data layer we need to change the references in every layer (web and service), then we need to deploy the server with 'PYTHONPATH=. poetry run python...' and we need to pay attention on the paths decorator for each endpoint. Some interesting observation or problem that appears here is that when we define some class with a name with white space like 'lucas acosta' the db brakes, perhaps more research is needed on this situation. Another problem that appeared is that we change every layer for access to the new data layer but not the model layer, when we pass the create endpoint some data that did not comply with the rules of this layer break the app. Continues reading from page 163
-(2025-05-14) in the last part of chapter 10 we test the endpoints fore CRUD, for that purpose we call the command POST for Create, GET for Retrive, PATCH for Update and DELETE for Delete. This HTTP requests actions are linked to a path endpoint of the web layer, something that we learn or discover is that the prescence of spaces in the name of the Creature instance when we create and then retrive the data from the endpoint is not a problem, the problem is that we where putting a comma between parameter when run the POST request and this break the syntax of the data (the comma is introduced in the value of the paremeter). Other thing that we learn is the different status code for specify the result of a request. We learn how to handle missing data and duplicate data, for that we need to create a new module called 'common' fromm this we gonna call inside of the data layer and the web layer the instances necessary for reproduce the messages, this messages gonna be created in the data layer, pass through the service layer and taked for the web layer for diplay in the response of the request. Important here is that in the delete function of the data layer when we try to call some value missing the sql module retunr a value of 0 and dont pop an error so the algorithm for assert the missing value is not function. For change this we need to refactor the algorithm for count how values response the DB. Lastly we try to use the module pytest for automatic testing but this not work like we expected. A lot of the code in the book is bad so maybe talking to ChatGpt helps. For more information on problems we encounter, read the chat with openAI bot in this day
-(2025-05-19) in the last part of the chapter 10 we try to test the logic of the service with pytest, this test outputs various errors, with the help of chatbots we encounter the problem. The test file for automatic test with pytest was pointing to the module of creatures when the logic to test was made in the explorer module. We found error in the books code. Remember that for the test we need to run the testing with 'PYTHOTPATH=. poetry run pytest <path to the .py file>'
-(2025-05-19) we start with the chapter 11 were we learn about authentication (authn) and authorization (authz). This two concepts facilitates security and control over the effectiveness of the website. Allows know the number of unique visitors, what are the most popular pages, if changes in the website increase the views and others effective ratios. In this first part we learn that for true security we need to use HTTPS instead of HTTP and we see how to implement a simple auth logic in fastAPI, this use simples variables that saves password and user name like str and receives http request with this data, control if that data exist and pass the response. For the previous logic we use some new classes of fastapi module like HTTPBasics and HTTPBasics.Credentials. This is just an example like how the auth and auhtz is used in reality this is not secure. For thar reason the book introduces OAuth2 standardization.
-(2025-05-20) continue the chapter 11 we remember the purpose of the two concepts, authentication is for know how are the user and authorization is for know what service the user want and can access. Here introduces first concepts to OAuth2 'Open Authorization' this is a standard protocol defined by the industry for allow websites access to resources hosted by other websites. We learn the needs for handle OAuth2, JWT (JsonWebToken) handling - with python-jose[cryptography] (JavascriptObjectSigningEncyptation) for handling token identifications, password handling - with passlib module, handling data from forms of the login logic with python-multipart module. For the last part of this day we design the logic for manage authz bottom-up, meaning that we start with the model layer were we define the classes for the login (User) then pass to the data layer and develop the tables in the db and the functions for CRUD (CreateRetrieveUpdateDelete), in the midle we create a fake data layer for test all the service without the need to define others layers with detail. Continue from the page 186 with the service and web layer
-(2025-05-21) we develop the data layer. Key ideas was to load the variables defined in the .env file, we did that with the dotenv module, this is used for the benefit of not define and environment variable in the system and defined just locally. In this layer we define the major part of the authorization logic. For now the code is calling to the fake module if the db is not defined in the .env, with this we avoid the crash of the run. For the logic of authz we need to import jwt from jose lib and CryptContex from pasllib.contex lib. Then in the code we define the SECRET_KEY, the ALGORITHM for the encode and the pwd_context for the same purpose, probably we gonna define in the .env file for production. Then we define the verify password for verify the password pased with the hash, here is used the CryptContext. The get hash function for create the hash of the password with the CryptContext (we se the relation in this firs two functions). Then the get_jwt_username take a token and return and username or none, this return only the username str-type. Then get_current_user, this return a User instance. A lookup_user function for the previous function. An auth_user function that takes name and plain pass and return user if is authenticate. Finally and create_access_token function for create the token, this have in minds the expires time of the token. The rest of the data layer is the passthrough of CRUD functions. CONTINUE FROM PAGE 187
-(2025-05-21) in practice to call request for the service we see that the explore service is nicely working and the creture services need to debug. We remember how to call the end points <parameter_name>='<value>'
- (2025-05-28) we execute all the service for remember how to. Here are interesting things of these process: for run the server (uvicorn), go to the directory where the the 'main.py' file is located, run this file in a bash or other type of terminal with the PYTHONPATH=. for define that this directory is a location of modules for the logic. For make the requests to the endpoints we need to open another terminal and located in the same directory, then with poetry dependency manager we call the commands for run the http request like 'poetry run http...(GET,POST,PATH,DELETE) localhost:8000/endpoint/'. For pass the parameters to the request we need just to pass like variables names and a designation. Something very interesting was that the Creature service was not entirely developed, so when we complete this and run the request the programm, server, logic crash, this was because we only complete the development in the data layer and not in the web layer, the explicit error was that we where handling missing and duplicate datas in the data layer, this pass through the service layer (it serves to this unique purpose) and in the web layer was not handled so crash. With the reading of yesterday in DBMS we learn that the inserts action to de sqlite3 are not effective because we do not commit that changes. Next thing to do is to try change the sqlite3 for the psycopg for PostgreSQL and create an endpoint to delete everything in the table. Continue the read for the book about fastAPI from where we left off
- (2025-05-31) we resume the lecture on the chapter 11 we see how works the data and service layer of the user endpoint, we do not understand why the service layer here is defined with some logic when in previous chapter the idea of the service layer was for pasthrought of the functions between the data layer and the web layer (need more research). Like the previous day on this topic 'fastAPI' we define a function for delete all the data in the DBMS sqlite3 in this case but we not inplement yet the PostgreSQL logic. We learn about asyncio python library that we need to use for manage async task manually suchs as concurrency, but not need if we use some other library that support asynchronous compatibility. For the reason of use asynchronous task in DBMS world we have asyncpg for PostgreSQL. This topic in async task is interesting for develop a service that suport scalability in the load of the clients. See the chat with Microsoft Copilot of this day for more info. We need to return to the page 183 for finish the web layer and test the new logic of user endpoint. We need to prove the benefits of async library with simple examples
- (2025-06-01) in this iteration of the process for create a fastAPI service we learn for what reason the service layer has some logic define in it and is not only for pass logics between the web layer and the data layer, the motive is that, for best practices and security the architecture of the service may do the next things, the web layer may handle HTTP I/O, requests parsing and response formatting, the service layer may manage the business logic, decisions, validations and transformations, the data layer may manage the low-level access of data access. Hashing the password is business logic so is defined in the service layer, in the first definitions of the logics we have logics about the DB so that logic was defined in the data layer, the service layer can have business logic to. In the same way this architecture reinforce the rule of 'password must be stored hashed' so the service layer pass the password hashed to the data layer, this comes with other benefit the data layer never see the plain text of the password wich is a security concern.
- (2025-06-01) for the previous idea the book do not develop the code for hash a plain text variable of the password, so for that reason and with the help of a AI copilot (openAI) we develop the model layer that accept two types of users objects, one with a attribute of plain text and a username and other with the attribute of a hash value and a username. For the same reason we develop the service layer for take a user object with a plain text and convert to a hash text then pass to the data layer. The key insight is that the plain text is hashed in the service layer and then pass to de data layer for the reason of security.
- (2025-06-01) in the process of develop this logic we find that some of our functions in the web layer was defined like async funcctions, this cost errors because this layer the functions in the others and that functions where no async functions. The copilot recommends that if the process is not I/O, normally the process over DB calls http requests and file reads are I/O when come from different clietns.
- (2025-06-01) we learn about the logic for authenticate the clients and why this is developed in the web layer, and is because HTTP-specific tools like OAuth2 are in the scope of the web layer that is not business logic but it is HTTP requests management. On the other hand the validation logic lives in the service layer, and the DB queries are in the data layer, so all is in order.
- (2025-06-01) the idea developed in this iteration make us came to the conclusion of the need to understand with a flowchart what is happening in our services, what layer call what layer and what do the functions called. We see to that understand how it works or how the cliete gonna use the authenticate token is a good idea.
- (2025-06-02) we learn more about the scope of each layer about the best practice for the architecture that look for the separations of concerns. The authentication consist in two concers, for that way, is developed in two differents layers; service layer manage the business logic, like checking password, generation token and hashing plain text; the web layer manage the http logic take request in forms or headers and return the responses. For this reason we have some 'logic' in the web layer and in the service layer
-(2025-06-02) then we learn how to GET the authenticated user in that endpoint, we learn that this endpoint is linked to a function that return the token that is passed like an header to the endpoint. We remember what does the function Depends() from FastAPI, this tell to a function that the parameter that recieves may be exactly something that is defined inside the parenthesis. We learn to that the OAuth2PassswordBearer(tokenUrl=token) automatically expects the token to be sent via the Authorization header and the function linked to the GET endpoint depends on it. Whe remember the different ways to parse an HTTP request, like query requests and header requests and view the key difference between them the first is public via the url and the last one is mor privately, this last affirmation do not mean that no body can access to it, for that reason is needit HTTPS
-(2025-06-03) we identify that the GET endpoint for get the 'service' for the user that is requesting only return the token that was passed through the header and that the logic for implementation of the validation was not in place. Yesterday we pass through the flow of this logic and identify two functions that where not used in the service layer. That functions are defined for verifying if the user that request the service has the necessary permission. We have wto functions, one take the token a str variable and decodes with the same setup we difine in that layer, for that reason use the secret key and the algorithm for encoding and decoding it verify the exp variable to, that last variable define if the token time expires, if all of this is acomplish then return the value of the username that is saved in a dictionary called payload (for good practices purpose). Then the other function take this value that is a name of the user in str type and search this value with the help of function defined in the data layer, used for search in the DB, if exist is returned the object if not then None.
- (2025-06-03) like we say in the previous text we want to implement the logic for verify if the user request have access to call this endpoint with a specific service, like we do not have the service defined we just gonna return the username value for the purpose of verify. So we implement the lasts functions in the GET endpoint and verify that it works. Interesting thing that we see to is that this logic catch if the time of the token reach his expiration
- (2025-06-03) in the last part of this iteration we review the future content of the book for the reason of selecting what chapters will help us with our purpose, then with tthe help of an AI copilot we explain the idea for the ML app and request that select the chapters that will help us. This repdroduce the next list of chapters: Ch 12 - Testing, Ch 13 - Production, Ch 14 -Databases, Ch 16 - Forms and Templates, Ch 17 - Data Discovery and Visualization. Then we ask about if is necessary for an API with shiny for python and it is not but for scalability it is necessary, work in this last idea
